import java.nio.file.Files
import java.nio.file.Paths
import java.util.zip.ZipFile

/*
 * Copyright 2014 serso aka se.solovyev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * Contact details
 *
 * Email: se.solovyev@gmail.com
 * Site:  http://se.solovyev.org
 */

apply plugin: 'com.android.library'

android {
    compileSdkVersion versions.sdk.compile
    defaultConfig {
        minSdkVersion versions.sdk.min
        targetSdkVersion versions.sdk.target
        consumerProguardFiles 'proguard-rules.txt'
    }
    lintOptions {
        abortOnError false
    }
}

dependencies {
    api 'com.google.code.findbugs:jsr305:3.0.2'
    implementation "com.android.billingclient:billing:${versions.libs.billing}"

    testImplementation 'junit:junit:4.13.2'
    testImplementation 'org.robolectric:robolectric:4.5.1'
    testImplementation "org.mockito:mockito-all:1.9.5"
    testImplementation "org.skyscreamer:jsonassert:1.5.0"
}

tasks.withType(Test) {
    scanForTestClasses = false
    include "**/*Test.class"
}

configurations {
    // A bogus config just to get hold of the module classpath and not fail with the following error:
    //   Resolving dependency configuration 'implementation' is not allowed as it is defined as 'canBeResolved=false'.
    //   Instead, a resolvable ('canBeResolved=true') dependency configuration that extends 'implementation' should
    //   be resolved.
    myConfig.extendsFrom implementation
}

task androidJavadocs(type: Javadoc) {
    source = android.sourceSets.main.java.srcDirs
    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
    configurations.myConfig.each { File file -> classpath += project.files(file.path) }

    // Copied from https://stackoverflow.com/a/43007253.
    // Abstract: Javadoc doesn't support .aar archives in the classpath. Let's collect all
    // .aar archives, extract their 'classes.jar' into a temporary build folder and use them
    // instead of the .aar files.
    afterEvaluate {
        // Process AAR dependencies
        def aarDependencies = classpath.filter { it.name.endsWith('.aar') }
        classpath -= aarDependencies
        aarDependencies.each { aar ->
            // Extract classes.jar from the AAR dependency, and add it to the javadoc classpath
            def outputPath = "$buildDir/tmp/aarJar/${aar.name.replace('.aar', '.jar')}"
            classpath += files(outputPath)

            // Use a task so the actual extraction only happens before the javadoc task is run
            dependsOn task("extractAar${aar.name}").doLast {
                extractEntry(aar, 'classes.jar', outputPath)
            }
        }
    }
}

// Utility method to extract only one entry in a zip file
private static def extractEntry(archive, entryPath, outputPath) {
    if (!archive.exists()) {
        throw new GradleException("archive $archive not found")
    }

    def zip = new ZipFile(archive)
    zip.entries().each {
        if (it.name == entryPath) {
            def path = Paths.get(outputPath)
            if (!Files.exists(path)) {
                Files.createDirectories(path.getParent())
                Files.copy(zip.getInputStream(it), path)
            }
        }
    }
    zip.close()
}

task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
    archiveExtension.set('javadoc')
    from androidJavadocs.destinationDir
}

task androidSourcesJar(type: Jar) {
    archiveExtension.set('sources')
    from android.sourceSets.main.java.srcDirs
}

afterEvaluate {
    publishing {
        publications {
            releaseLib(MavenPublication) {
                from components.release

                artifact androidSourcesJar
                artifact androidJavadocsJar

                artifactId = 'checkout'
                configurePublication(releaseLib, 'aar')
            }
        }
    }
}
